# frozen_string_literal: true

require "railsplan/ai_provider/base"
require "open3"
require "json"
require "tempfile"

module RailsPlan
  module AIProvider
    # Cursor provider implementation using local Cursor instance via stdin/stdout
    class Cursor < Base
      CURSOR_COMMAND = "cursor"
      CURSOR_CLI_COMMAND = "cursor-cli"
      
      def call(prompt, context, format, options = {})
        full_prompt = build_full_prompt(prompt, context, format)
        
        begin
          # Check if Cursor is available
          cursor_command = find_cursor_command
          unless cursor_command
            raise RailsPlan::Error, "Cursor not found. Install Cursor or ensure it's in your PATH."
          end
          
          # Create temporary files for input and output
          result = nil
          Tempfile.create(["railsplan_cursor_input", ".md"]) do |input_file|
            Tempfile.create(["railsplan_cursor_output", ".md"]) do |output_file|
              # Write prompt to input file
              input_file.write(full_prompt)
              input_file.flush
              
              # Prepare context file if needed
              context_file_path = prepare_context_file(context) if context && !context.empty?
              
              # Execute Cursor command
              result = execute_cursor(cursor_command, input_file.path, output_file.path, context_file_path, options)
              
              # Clean up context file
              File.delete(context_file_path) if context_file_path && File.exist?(context_file_path)
            end
          end
          
          result
          
        rescue => error
          handle_api_error(error)
        end
      end
      
      # Override configured check for Cursor
      def configured?
        !find_cursor_command.nil?
      end
      
      # Override client method since we don't use HTTP client
      def client
        find_cursor_command
      end
      
      private
      
      def find_cursor_command
        # Try different possible Cursor commands
        commands = [CURSOR_CLI_COMMAND, CURSOR_COMMAND, "code"]
        
        commands.each do |cmd|
          if system("which #{cmd} > /dev/null 2>&1")
            return cmd
          end
        end
        
        # Check common installation paths
        common_paths = [
          "/usr/local/bin/cursor",
          "/usr/bin/cursor",
          "#{ENV['HOME']}/.cursor/bin/cursor",
          "/Applications/Cursor.app/Contents/Resources/app/bin/cursor"
        ]
        
        common_paths.each do |path|
          return path if File.executable?(path)
        end
        
        nil
      end
      
      def prepare_context_file(context)
        context_file = Tempfile.create(["railsplan_context", ".json"])
        context_file.write(JSON.pretty_generate(context))
        context_file.flush
        context_file.close
        context_file.path
      end
      
      def execute_cursor(cursor_command, input_path, output_path, context_path, options)
        start_time = Time.now
        
        # Build command arguments
        command_args = build_cursor_args(cursor_command, input_path, output_path, context_path, options)
        
        # Execute command with timeout
        stdout, stderr, status = nil, nil, nil
        timeout = options[:timeout] || 120 # 2 minutes default timeout
        
        begin
          Timeout::timeout(timeout) do
            stdout, stderr, status = Open3.capture3(*command_args)
          end
        rescue Timeout::Error
          raise RailsPlan::Error, "Cursor command timed out after #{timeout} seconds"
        end
        
        end_time = Time.now
        execution_time = end_time - start_time
        
        # Check if command was successful
        unless status.success?
          error_msg = "Cursor command failed with exit code #{status.exitstatus}"
          error_msg += "\nStderr: #{stderr}" unless stderr.empty?
          error_msg += "\nStdout: #{stdout}" unless stdout.empty?
          raise RailsPlan::Error, error_msg
        end
        
        # Read output
        output = if File.exist?(output_path) && !File.zero?(output_path)
                   File.read(output_path).strip
                 elsif !stdout.empty?
                   stdout.strip
                 else
                   raise RailsPlan::Error, "No output generated by Cursor"
                 end
        
        # Estimate tokens (rough calculation: ~4 characters per token)
        estimated_tokens = (output.length / 4.0).round
        
        metadata = {
          model: "cursor-local",
          execution_time: execution_time,
          total_tokens: estimated_tokens,
          tokens_used: estimated_tokens,
          cost_estimate: 0.0, # Local execution is free
          command: command_args.join(" "),
          exit_code: status.exitstatus
        }
        
        validate_response({
          output: output,
          metadata: metadata
        })
      end
      
      def build_cursor_args(cursor_command, input_path, output_path, context_path, options)
        args = [cursor_command]
        
        # Different approaches based on the command available
        case File.basename(cursor_command)
        when "cursor-cli", "cursor"
          # If cursor CLI is available, use it for batch processing
          args += ["--batch", "--input", input_path, "--output", output_path]
          args += ["--context", context_path] if context_path
          args += ["--format", options[:format].to_s] if options[:format]
        when "code"
          # Fallback to VS Code if Cursor isn't available
          # This is a simplified approach - in practice, you'd need cursor-specific extensions
          args += ["--wait", "--new-window", input_path]
        else
          # Generic approach - just open the file
          args += [input_path]
        end
        
        args
      end
      
      def calculate_cost(tokens)
        0.0 # Local execution is free
      end
      
      def extract_token_usage(response_metadata)
        response_metadata[:total_tokens] || 0
      end
    end
  end
end