#!/usr/bin/env ruby
# frozen_string_literal: true

# Simple CLI implementation without external dependencies for the starter template
require 'fileutils'
require 'json'
require 'pathname'

# Documentation generator for Synth modules
class DocumentationGenerator
  DOMAINS_PATH = File.expand_path('../app/domains', __dir__)
  DOCS_PATH = File.expand_path('../docs', __dir__)
  SWAGGER_PATH = File.expand_path('../swagger', __dir__)
  
  def initialize
    @verbose = false
  end
  
  def generate_all
    ensure_docs_directory
    
    puts "üìö Generating documentation from installed modules..."
    
    # Generate main README with all installed modules
    generate_main_readme
    
    # Generate individual module docs
    generate_module_docs
    
    # Generate OpenAPI documentation if API module is installed
    generate_api_docs if api_module_installed?
    
    puts "‚úÖ Documentation generation complete!"
    puts "üìñ Main documentation: docs/README.md"
    puts "üóÇÔ∏è  Module documentation: docs/modules/"
    puts "üîó API documentation: docs/api.json" if api_module_installed?
  end
  
  private
  
  def ensure_docs_directory
    FileUtils.mkdir_p(DOCS_PATH)
    FileUtils.mkdir_p(File.join(DOCS_PATH, 'modules'))
  end
  
  def generate_main_readme
    installed_modules = get_installed_modules
    
    main_readme = <<~MARKDOWN
      # #{app_name} Documentation

      This documentation is auto-generated from installed Synth modules and OpenAPI specifications.

      ## Overview

      This Rails SaaS application is built using the Rails SaaS Starter Template with the following installed modules:

      #{generate_modules_overview(installed_modules)}

      ## Quick Start

      ### Prerequisites

      - Ruby 3.3.0 or later
      - Node.js 18 or later
      - PostgreSQL 14+ with pgvector extension
      - Redis 6 or later

      ### Installation

      ```bash
      # Clone and setup
      git clone <repository-url>
      cd <app-name>
      bundle install
      yarn install

      # Database setup
      rails db:create
      rails db:migrate
      rails db:seed

      # Start development server
      bin/dev
      ```

      ## Module Documentation

      #{generate_modules_list(installed_modules)}

      #{generate_api_section if api_module_installed?}

      ## Synth CLI

      Use the Synth CLI to manage modules:

      ```bash
      # List available modules
      bin/synth list

      # Add new modules
      bin/synth add [module_name]

      # Remove modules
      bin/synth remove [module_name]

      # Generate documentation
      bin/synth docs
      ```

      ---

      *Documentation generated on #{Time.now.strftime('%Y-%m-%d %H:%M:%S')} by `bin/synth docs`*
    MARKDOWN
    
    File.write(File.join(DOCS_PATH, 'README.md'), main_readme)
    puts "‚úÖ Generated main README.md"
  end
  
  def generate_module_docs
    get_installed_modules.each do |module_name|
      module_readme_path = File.join(DOMAINS_PATH, module_name, 'README.md')
      next unless File.exist?(module_readme_path)
      
      # Copy module README to docs/modules/
      module_content = File.read(module_readme_path)
      output_path = File.join(DOCS_PATH, 'modules', "#{module_name}.md")
      File.write(output_path, module_content)
      
      puts "‚úÖ Generated docs/modules/#{module_name}.md"
    end
  end
  
  def generate_api_docs
    swagger_files = Dir.glob(File.join(SWAGGER_PATH, '**/*.{json,yaml,yml}'))
    return if swagger_files.empty?
    
    # Copy the main swagger file to docs/
    main_swagger = swagger_files.find { |f| f.include?('swagger') } || swagger_files.first
    if main_swagger && File.exist?(main_swagger)
      target_path = File.join(DOCS_PATH, 'api.json')
      
      if main_swagger.end_with?('.json')
        FileUtils.cp(main_swagger, target_path)
      else
        # Convert YAML to JSON if needed
        require 'yaml'
        yaml_content = YAML.load_file(main_swagger)
        File.write(target_path, JSON.pretty_generate(yaml_content))
      end
      
      puts "‚úÖ Generated API documentation from OpenAPI schema"
    end
  rescue => e
    puts "‚ö†Ô∏è  Warning: Could not generate API docs: #{e.message}"
  end
  
  def get_installed_modules
    return [] unless Dir.exist?(DOMAINS_PATH)
    
    Dir.children(DOMAINS_PATH).select do |dir|
      File.directory?(File.join(DOMAINS_PATH, dir))
    end.sort
  end
  
  def generate_modules_overview(modules)
    return "No modules installed." if modules.empty?
    
    overview = modules.map do |module_name|
      readme_path = File.join(DOMAINS_PATH, module_name, 'README.md')
      description = if File.exist?(readme_path)
        extract_description_from_readme(File.read(readme_path))
      else
        "No description available"
      end
      
      "- **#{module_name.capitalize}**: #{description}"
    end
    
    overview.join("\n")
  end
  
  def generate_modules_list(modules)
    return "No modules installed." if modules.empty?
    
    list = modules.map do |module_name|
      "- [#{module_name.capitalize}](modules/#{module_name}.md)"
    end
    
    list.join("\n")
  end
  
  def generate_api_section
    return "" unless api_module_installed?
    
    <<~MARKDOWN
      ## API Documentation

      This application provides a JSON:API compliant REST API. 

      - **OpenAPI Specification**: [api.json](api.json)
      - **API Module Documentation**: [modules/api.md](modules/api.md)

      ### Authentication

      Most API endpoints require authentication using Bearer tokens.

      ### Base URL

      - Development: `http://localhost:3000/api`
      - Production: `https://your-domain.com/api`
    MARKDOWN
  end
  
  def api_module_installed?
    Dir.exist?(File.join(DOMAINS_PATH, 'api'))
  end
  
  def app_name
    # Try to extract app name from various sources
    if File.exist?('config/application.rb')
      content = File.read('config/application.rb')
      match = content.match(/module\s+(\w+)/)
      return match[1] if match
    end
    
    File.basename(Dir.pwd).split(/[-_]/).map(&:capitalize).join(' ')
  end
  
  def extract_description_from_readme(content)
    lines = content.split("\n")
    
    # Find first non-header line that has content
    description_line = lines.find do |line|
      line.strip.length > 0 && 
      !line.start_with?('#') && 
      !line.strip.match?(/^[\*\-\+]\s/) # Skip list items
    end
    
    return "No description available." unless description_line
    
    # Clean up the description
    description_line.strip.gsub(/\*\*(.*?)\*\*/, '\1').truncate(120)
  end
end

# String truncate helper
class String
  def truncate(length, omission = '...')
    if self.length > length
      self[0, length - omission.length] + omission
    else
      self
    end
  end
end

class SynthCLI
  TEMPLATE_PATH = File.expand_path('../scaffold/lib/templates/synth', __dir__)
  REGISTRY_PATH = File.expand_path('../scaffold/config/synth_modules.json', __dir__)
  
  def initialize
    @verbose = ARGV.include?('--verbose') || ARGV.include?('-v')
  end

  def self.start(args)
    cli = new
    command = args.first
    
    case command
    when 'list'
      cli.list
    when 'add'
      module_name = args[1]
      unless module_name
        puts "‚ùå Module name required. Usage: bin/synth add MODULE_NAME"
        exit 1
      end
      cli.add(module_name)
    when 'remove'
      module_name = args[1]
      unless module_name
        puts "‚ùå Module name required. Usage: bin/synth remove MODULE_NAME"
        exit 1
      end
      cli.remove(module_name)
    when 'info'
      module_name = args[1]
      unless module_name
        puts "‚ùå Module name required. Usage: bin/synth info MODULE_NAME"
        exit 1
      end
      cli.info(module_name)
    when 'test'
      module_name = args[1]
      cli.test(module_name)
    when 'doctor'
      cli.doctor
    when 'docs'
      cli.docs
    when 'upgrade'
      module_name = args[1..-1].find { |arg| !arg.start_with?('--') && !arg.start_with?('-') }
      cli.upgrade(module_name)
    when 'help', '--help', '-h', nil
      cli.show_help
    else
      puts "‚ùå Unknown command: #{command}"
      cli.show_help
      exit 1
    end
  end

  def list
    show_available_modules
    puts ""
    show_installed_modules
  end

  def add(module_name)
    module_template_path = File.join(TEMPLATE_PATH, module_name)
    
    unless Dir.exist?(module_template_path)
      puts "‚ùå Module '#{module_name}' not found in templates"
      show_available_modules
      exit 1
    end

    if module_installed?(module_name) && !force_mode?
      puts "‚ö†Ô∏è  Module '#{module_name}' is already installed. Use --force to reinstall."
      exit 1
    end

    install_module(module_name, module_template_path)
  end

  def remove(module_name)
    unless module_installed?(module_name)
      puts "‚ùå Module '#{module_name}' is not installed"
      show_installed_modules
      exit 1
    end

    unless force_mode?
      print "Are you sure you want to remove '#{module_name}'? This will delete files and may cause data loss. [y/N]: "
      confirmation = STDIN.gets.chomp.downcase
      unless confirmation == 'y' || confirmation == 'yes'
        puts "‚ùå Module removal cancelled"
        exit 1
      end
    end

    remove_module(module_name)
  end

  def info(module_name)
    show_module_info(module_name)
  end

  def test(module_name = nil)
    if module_name
      test_single_module(module_name)
    else
      test_all_modules
    end
  end

  def doctor
    puts 'üè• Running system diagnostics...'
    
    results = []
    results << check_ruby_version
    results << check_template_structure
    results << check_registry_integrity
    results << check_environment_variables
    results << check_api_keys
    results << check_pending_migrations
    results << check_module_integrity
    
    puts "\nüè• Diagnostics complete"
    
    failed_checks = results.count(false)
    if failed_checks > 0
      puts "‚ùå #{failed_checks} check(s) failed"
      puts "\nüí° Run with suggestions above to fix issues"
      exit 1
    else
      puts "‚úÖ All checks passed"
    end
  end

  def upgrade(module_name = nil)
    backup_enabled = !ARGV.include?('--no-backup')
    non_interactive = ARGV.include?('--yes') || ARGV.include?('-y')
    
    if module_name
      upgrade_single_module(module_name, backup_enabled, non_interactive)
    else
      upgrade_all_modules(backup_enabled, non_interactive)
    end
    
    # Regenerate documentation after upgrade
    puts "üìö Regenerating documentation after upgrade..."
    docs
  end

  def docs
    puts "üìö Generating documentation from installed modules..."
    
    begin
      generator = DocumentationGenerator.new
      generator.generate_all
      puts "‚úÖ Documentation generated successfully!"
      puts "üìñ Main documentation available at: docs/README.md"
      puts "üóÇÔ∏è  Module documentation available at: docs/modules/"
    rescue => e
      puts "‚ùå Error generating documentation: #{e.message}"
      puts e.backtrace.first(3).join("\n") if @verbose
      exit 1
    end
  end

  def show_help
    puts <<~HELP
      bin/synth - Rails SaaS Starter Template Module Manager
      
      USAGE:
        bin/synth COMMAND [OPTIONS]
      
      COMMANDS:
        list                  List available and installed modules
        add MODULE            Install a feature module
        remove MODULE         Uninstall a feature module  
        info MODULE           Show detailed information about a module
        test [MODULE]         Run tests for a module or all modules
        docs                  Generate documentation from installed modules and OpenAPI schema
        upgrade [MODULE]      Upgrade one or all installed modules to latest versions
        doctor                Validate setup and configuration
        help                  Show this help message
      
      OPTIONS:
        --verbose, -v         Enable verbose output
        --force, -f           Force operation without confirmation
        --yes, -y             Auto-confirm prompts (non-interactive mode)
        --no-backup           Skip creating backups during upgrades
      
      UPGRADE OPTIONS:
        upgrade               Upgrade all installed modules
        upgrade MODULE        Upgrade specific module only
        upgrade --yes         Upgrade without prompting for conflicts
        upgrade --no-backup   Upgrade without creating backups
      
      EXAMPLES:
        bin/synth list
        bin/synth add billing
        bin/synth remove cms --force
        bin/synth info ai
        bin/synth test billing
        bin/synth docs
        bin/synth upgrade
        bin/synth upgrade ai --verbose
        bin/synth upgrade --yes --no-backup
        bin/synth doctor
    HELP
  end

  private

  def show_available_modules
    puts 'üì¶ Available modules:'
    
    unless Dir.exist?(TEMPLATE_PATH)
      puts '  (templates directory not found)'
      return
    end

    modules = Dir.children(TEMPLATE_PATH).select { |d| File.directory?(File.join(TEMPLATE_PATH, d)) }
    
    if modules.empty?
      puts '  (no modules found)'
      return
    end

    modules.sort.each do |module_name|
      module_path = File.join(TEMPLATE_PATH, module_name)
      readme_path = File.join(module_path, 'README.md')
      version_path = File.join(module_path, 'VERSION')
      
      description = if File.exist?(readme_path)
        File.readlines(readme_path).first&.strip&.gsub(/^#\s*/, '') || 'No description'
      else
        'No description'
      end
      
      version = if File.exist?(version_path)
        File.read(version_path).strip
      else
        'unknown'
      end
      
      installed = module_installed?(module_name)
      status_icon = installed ? '‚úÖ' : '  '
      
      puts "  #{status_icon} #{module_name.ljust(15)} v#{version.ljust(8)} - #{description}"
    end
  end

  def show_installed_modules
    puts 'üîß Installed modules:'
    
    registry = load_registry
    installed_modules = registry['installed'] || {}
    
    if installed_modules.empty?
      puts '  (no modules installed)'
      return
    end

    installed_modules.each do |module_name, info|
      version = info['version'] || 'unknown'
      installed_at = info['installed_at'] ? info['installed_at'][0..9] : 'unknown'
      puts "  ‚úÖ #{module_name.ljust(15)} v#{version.ljust(8)} (installed: #{installed_at})"
    end
  end

  def install_module(module_name, module_template_path)
    puts "üì¶ Installing #{module_name} module..."
    
    install_file = File.join(module_template_path, 'install.rb')
    
    unless File.exist?(install_file)
      puts "‚ùå Module installer not found: #{install_file}"
      exit 1
    end

    begin
      # Load version info
      version_path = File.join(module_template_path, 'VERSION')
      version = File.exist?(version_path) ? File.read(version_path).strip : '1.0.0'
      
      # Create basic directories if they don't exist
      create_basic_directories
      
      # Copy module files to app/domains
      copy_module_files(module_name, module_template_path)
      
      # Update registry
      update_registry(module_name, {
        'version' => version,
        'installed_at' => Time.now.strftime('%Y-%m-%dT%H:%M:%S%z'),
        'template_path' => module_template_path
      })
      
      puts "‚úÖ Successfully installed #{module_name} module!"
      log_module_action(:install, module_name, version)
      
    rescue StandardError => e
      puts "‚ùå Error installing module: #{e.message}"
      puts e.backtrace.first(5).join("\n") if @verbose
      log_module_action(:error, module_name, e.message)
      exit 1
    end
  end

  def remove_module(module_name)
    puts "üóëÔ∏è  Removing #{module_name} module..."
    
    registry = load_registry
    module_info = registry.dig('installed', module_name)
    
    unless module_info
      puts "‚ùå Module not found in registry"
      exit 1
    end

    begin
      # Default removal logic
      default_module_removal(module_name)
      
      # Remove from registry
      registry['installed'].delete(module_name)
      save_registry(registry)
      
      puts "‚úÖ Successfully removed #{module_name} module!"
      log_module_action(:remove, module_name)
      
    rescue StandardError => e
      puts "‚ùå Error removing module: #{e.message}"
      puts e.backtrace.first(5).join("\n") if @verbose
      log_module_action(:error, module_name, e.message)
      exit 1
    end
  end

  def show_module_info(module_name)
    module_template_path = File.join(TEMPLATE_PATH, module_name)
    
    unless Dir.exist?(module_template_path)
      puts "‚ùå Module '#{module_name}' not found"
      exit 1
    end

    puts "üìã Module: #{module_name}"
    puts "=" * 50
    
    # Basic info
    readme_path = File.join(module_template_path, 'README.md')
    if File.exist?(readme_path)
      puts "\nüìñ Description:"
      puts File.read(readme_path).lines.first(5).join
    end
    
    # Version
    version_path = File.join(module_template_path, 'VERSION')
    if File.exist?(version_path)
      puts "\nüè∑Ô∏è  Version: #{File.read(version_path).strip}"
    end
    
    # Installation status
    if module_installed?(module_name)
      registry = load_registry
      info = registry.dig('installed', module_name)
      puts "\n‚úÖ Status: Installed"
      puts "   Installed version: #{info['version']}" if info['version']
      puts "   Installed at: #{info['installed_at']}" if info['installed_at']
    else
      puts "\n‚ùå Status: Not installed"
    end
    
    # Files
    puts "\nüìÅ Files:"
    Dir.glob(File.join(module_template_path, "**/*")).each do |file|
      next if File.directory?(file)
      relative_path = Pathname.new(file).relative_path_from(Pathname.new(module_template_path))
      puts "   #{relative_path}"
    end
  end

  def test_single_module(module_name)
    unless module_installed?(module_name)
      puts "‚ùå Module '#{module_name}' is not installed"
      exit 1
    end
    
    # Look for module-specific tests
    test_paths = [
      "spec/domains/#{module_name}",
      "test/domains/#{module_name}",
      "spec/#{module_name}",
      "test/#{module_name}"
    ]
    
    test_path = test_paths.find { |path| Dir.exist?(path) }
    
    if test_path
      puts "üß™ Running tests for #{module_name} module..."
      if test_path.start_with?('spec/')
        system("bundle exec rspec #{test_path}")
      else
        system("bundle exec rails test #{test_path}")
      end
    else
      puts "‚ùå No tests found for module: #{module_name}"
      exit 1
    end
  end

  def test_all_modules
    puts 'üß™ Running full test suite...'
    
    # Try RSpec first, then fall back to Minitest
    if File.exist?('spec/rails_helper.rb')
      system('bundle exec rspec')
    elsif File.exist?('test/test_helper.rb')
      system('bundle exec rails test')
    else
      puts "‚ùå No test framework detected"
      exit 1
    end
  end

  def upgrade_single_module(module_name, backup_enabled = true, non_interactive = false)
    unless module_installed?(module_name)
      puts "‚ùå Module '#{module_name}' is not installed"
      exit 1
    end
    
    registry = load_registry
    installed_info = registry.dig('installed', module_name)
    current_version = installed_info['version'] || '0.0.0'
    
    module_template_path = File.join(TEMPLATE_PATH, module_name)
    unless Dir.exist?(module_template_path)
      puts "‚ùå Module '#{module_name}' template not found"
      exit 1
    end
    
    available_version = get_module_version(module_template_path)
    
    if version_compare(available_version, current_version) <= 0
      puts "‚úÖ Module '#{module_name}' is already up to date (v#{current_version})"
      return
    end
    
    puts "üîÑ Upgrading #{module_name} from v#{current_version} to v#{available_version}..."
    
    # Create backup if enabled
    if backup_enabled
      backup_path = create_module_backup(module_name, current_version)
      puts "üíæ Created backup at #{backup_path}" if @verbose
    end
    
    # Check for conflicts and prompt user
    conflicts = detect_conflicts(module_name, module_template_path)
    if !conflicts.empty? && !non_interactive
      handle_conflicts(conflicts, module_name)
    end
    
    # Perform the upgrade
    perform_module_upgrade(module_name, module_template_path, current_version, available_version)
    
    puts "‚úÖ Successfully upgraded #{module_name} to v#{available_version}!"
    log_module_action(:upgrade, module_name, "#{current_version} -> #{available_version}")
  end

  def upgrade_all_modules(backup_enabled = true, non_interactive = false)
    registry = load_registry
    installed_modules = registry['installed'] || {}
    
    if installed_modules.empty?
      puts "üì¶ No modules installed to upgrade"
      return
    end
    
    upgradeable_modules = []
    installed_modules.each do |module_name, info|
      current_version = info['version'] || '0.0.0'
      module_template_path = File.join(TEMPLATE_PATH, module_name)
      
      next unless Dir.exist?(module_template_path)
      
      available_version = get_module_version(module_template_path)
      if version_compare(available_version, current_version) > 0
        upgradeable_modules << [module_name, current_version, available_version]
      end
    end
    
    if upgradeable_modules.empty?
      puts "‚úÖ All installed modules are up to date"
      return
    end
    
    puts "üîÑ Found #{upgradeable_modules.length} module(s) to upgrade:"
    upgradeable_modules.each do |name, current, available|
      puts "  üì¶ #{name}: v#{current} -> v#{available}"
    end
    
    unless non_interactive
      print "\nProceed with upgrades? [Y/n]: "
      confirmation = STDIN.gets.chomp.downcase
      if confirmation == 'n' || confirmation == 'no'
        puts "‚ùå Upgrade cancelled"
        return
      end
    end
    
    upgradeable_modules.each do |module_name, _, _|
      upgrade_single_module(module_name, backup_enabled, true) # Force non-interactive for bulk upgrades
    end
  end

  def module_installed?(module_name)
    registry = load_registry
    registry.dig('installed', module_name) != nil
  end

  def load_registry
    return { 'installed' => {} } unless File.exist?(REGISTRY_PATH)
    
    begin
      JSON.parse(File.read(REGISTRY_PATH))
    rescue JSON::ParserError
      puts "‚ö†Ô∏è  Registry file corrupted, resetting..." if @verbose
      { 'installed' => {} }
    end
  end

  def save_registry(registry)
    FileUtils.mkdir_p(File.dirname(REGISTRY_PATH))
    File.write(REGISTRY_PATH, JSON.pretty_generate(registry))
  end

  def update_registry(module_name, info)
    registry = load_registry
    registry['installed'] ||= {}
    registry['installed'][module_name] = info
    save_registry(registry)
  end

  def create_basic_directories
    %w[app/domains spec/domains test/domains].each do |dir|
      FileUtils.mkdir_p(dir) unless Dir.exist?(dir)
    end
  end

  def copy_module_files(module_name, module_template_path)
    target_dir = File.join('app', 'domains', module_name)
    
    # Remove existing if force mode
    if Dir.exist?(target_dir) && force_mode?
      FileUtils.rm_rf(target_dir)
    end
    
    # Create target directory
    FileUtils.mkdir_p(target_dir)
    
    # Copy README if it exists
    readme_source = File.join(module_template_path, 'README.md')
    if File.exist?(readme_source)
      FileUtils.cp(readme_source, File.join(target_dir, 'README.md'))
      puts "  ‚úÖ Copied README.md" if @verbose
    end
    
    # Copy other relevant files (excluding install.rb and VERSION)
    Dir.glob(File.join(module_template_path, "**/*")).each do |file|
      next if File.directory?(file)
      next if File.basename(file) == 'install.rb'
      next if File.basename(file) == 'VERSION'
      next if File.basename(file) == 'remove.rb'
      
      relative_path = Pathname.new(file).relative_path_from(Pathname.new(module_template_path))
      target_file = File.join(target_dir, relative_path)
      
      FileUtils.mkdir_p(File.dirname(target_file))
      FileUtils.cp(file, target_file)
      puts "  ‚úÖ Copied #{relative_path}" if @verbose
    end
  end

  def default_module_removal(module_name)
    # Remove from app/domains if it exists
    domains_path = File.join('app', 'domains', module_name)
    if Dir.exist?(domains_path)
      FileUtils.rm_rf(domains_path)
      puts "    üóëÔ∏è  Removed #{domains_path}" if @verbose
    end
    
    # Remove from spec/domains if it exists
    spec_path = File.join('spec', 'domains', module_name)
    if Dir.exist?(spec_path)
      FileUtils.rm_rf(spec_path)
      puts "    üóëÔ∏è  Removed #{spec_path}" if @verbose
    end
    
    # Remove from test/domains if it exists
    test_path = File.join('test', 'domains', module_name)
    if Dir.exist?(test_path)
      FileUtils.rm_rf(test_path)
      puts "    üóëÔ∏è  Removed #{test_path}" if @verbose
    end
  end

  def check_ruby_version
    puts "Ruby version: #{RUBY_VERSION}"
    true # Ruby is running, so version is adequate
  end

  def check_template_structure
    puts "\nChecking template structure:"
    
    if File.exist?(REGISTRY_PATH)
      puts "‚úÖ Module registry found"
      registry_ok = true
    else
      puts "‚ö†Ô∏è  Module registry not found at #{REGISTRY_PATH}"
      registry_ok = false
    end
    
    if Dir.exist?(TEMPLATE_PATH)
      puts "‚úÖ Module templates directory found"
      templates_ok = true
    else
      puts "‚ö†Ô∏è  Module templates directory not found at #{TEMPLATE_PATH}"
      templates_ok = false
    end
    
    registry_ok && templates_ok
  end

  def check_registry_integrity
    return true unless File.exist?(REGISTRY_PATH)
    
    begin
      registry = JSON.parse(File.read(REGISTRY_PATH))
      puts "‚úÖ Module registry is valid JSON"
      
      installed_count = registry.dig('installed')&.keys&.count || 0
      puts "üì¶ #{installed_count} module(s) registered as installed"
      true
    rescue JSON::ParserError
      puts "‚ùå Module registry is corrupted (invalid JSON)"
      false
    end
  end

  def check_environment_variables
    puts "\nChecking environment variables:"
    
    env_example_path = File.join(TEMPLATE_PATH, '..', '..', 'templates', '.env.example')
    unless File.exist?(env_example_path)
      puts "‚ö†Ô∏è  .env.example file not found at #{env_example_path}"
      return true # Not critical, continue
    end
    
    critical_vars = []
    required_vars = %w[
      SECRET_KEY_BASE
      DATABASE_URL
      REDIS_URL
    ]
    
    missing_vars = []
    required_vars.each do |var|
      unless ENV[var] && !ENV[var].empty?
        missing_vars << var
      end
    end
    
    if missing_vars.empty?
      puts "‚úÖ Critical environment variables are set"
      return true
    else
      puts "‚ùå Missing critical environment variables: #{missing_vars.join(', ')}"
      puts "üí° Create a .env file with these variables or set them in your environment"
      puts "üí° See .env.example for reference values"
      return false
    end
  end

  def check_api_keys
    puts "\nChecking API key configuration:"
    
    all_valid = true
    
    # Check OpenAI API key
    if ENV['OPENAI_API_KEY'] && !ENV['OPENAI_API_KEY'].empty?
      if ENV['OPENAI_API_KEY'].start_with?('sk-')
        puts "‚úÖ OpenAI API key format looks valid"
      else
        puts "‚ö†Ô∏è  OpenAI API key format appears invalid (should start with 'sk-')"
        all_valid = false
      end
    else
      puts "‚ö†Ô∏è  OpenAI API key not set (OPENAI_API_KEY)"
      puts "üí° Set OPENAI_API_KEY if you plan to use AI features"
    end
    
    # Check Stripe API key
    if ENV['STRIPE_SECRET_KEY'] && !ENV['STRIPE_SECRET_KEY'].empty?
      if ENV['STRIPE_SECRET_KEY'].start_with?('sk_')
        puts "‚úÖ Stripe secret key format looks valid"
      else
        puts "‚ö†Ô∏è  Stripe secret key format appears invalid (should start with 'sk_')"
        all_valid = false
      end
    else
      puts "‚ö†Ô∏è  Stripe secret key not set (STRIPE_SECRET_KEY)"
      puts "üí° Set STRIPE_SECRET_KEY if you plan to use billing features"
    end
    
    # Check GitHub token
    if ENV['GITHUB_TOKEN'] && !ENV['GITHUB_TOKEN'].empty?
      if ENV['GITHUB_TOKEN'].start_with?('ghp_') || ENV['GITHUB_TOKEN'].start_with?('github_pat_')
        puts "‚úÖ GitHub token format looks valid"
      else
        puts "‚ö†Ô∏è  GitHub token format appears invalid"
        all_valid = false
      end
    else
      puts "‚ö†Ô∏è  GitHub token not set (GITHUB_TOKEN)"
      puts "üí° Set GITHUB_TOKEN if you plan to use GitHub integration features"
    end
    
    if all_valid
      puts "‚úÖ API key formats appear valid"
    else
      puts "üí° Check API key formats and regenerate if necessary"
    end
    
    return all_valid
  end

  def check_pending_migrations
    puts "\nChecking database migrations:"
    
    migrations_dir = 'db/migrate'
    unless Dir.exist?(migrations_dir)
      puts "‚ö†Ô∏è  No migrations directory found at #{migrations_dir}"
      return true # Not in a Rails app context, skip
    end
    
    migration_files = Dir.glob(File.join(migrations_dir, '*.rb')).sort
    if migration_files.empty?
      puts "‚úÖ No migrations found"
      return true
    end
    
    puts "üìä Found #{migration_files.length} migration file(s)"
    
    # Check if Rails is available to check migration status
    begin
      # Try to detect if we're in a Rails app context
      if File.exist?('config/application.rb') || File.exist?('Rakefile')
        puts "üí° In Rails app context - run 'rails db:migrate:status' to check migration status"
        puts "üí° Run 'rails db:migrate' if there are pending migrations"
      else
        puts "‚ö†Ô∏è  Not in Rails app context - cannot check migration status"
        puts "üí° Ensure migrations are run when deploying the generated application"
      end
    rescue => e
      puts "‚ö†Ô∏è  Could not check migration status: #{e.message}"
    end
    
    return true # Don't fail on migration checks as this is informational
  end

  def check_module_integrity
    puts "\nChecking installed module integrity:"
    
    return true unless File.exist?(REGISTRY_PATH)
    
    begin
      registry = JSON.parse(File.read(REGISTRY_PATH))
      installed_modules = registry.dig('installed') || {}
      
      if installed_modules.empty?
        puts "‚úÖ No modules installed - registry is clean"
        return true
      end
      
      all_valid = true
      installed_modules.each do |module_name, module_info|
        domain_path = File.join('app', 'domains', module_name)
        template_path = module_info['template_path']
        
        # Check if domain directory exists
        unless Dir.exist?(domain_path)
          puts "‚ùå Module '#{module_name}' missing domain directory at #{domain_path}"
          puts "üí° Run 'bin/synth remove #{module_name}' and reinstall with 'bin/synth add #{module_name}'"
          all_valid = false
          next
        end
        
        # Check if template path exists
        unless Dir.exist?(template_path)
          puts "‚ùå Module '#{module_name}' missing template at #{template_path}"
          all_valid = false
          next
        end
        
        puts "‚úÖ Module '#{module_name}' appears properly installed"
      end
      
      if all_valid
        puts "‚úÖ All installed modules appear intact"
      end
      
      return all_valid
    rescue JSON::ParserError
      puts "‚ùå Cannot check module integrity - registry is corrupted"
      return false
    rescue => e
      puts "‚ùå Error checking module integrity: #{e.message}"
      return false
    end
  end

  def log_module_action(action, module_name, message = nil)
    log_file = 'log/synth.log'
    FileUtils.mkdir_p('log') unless Dir.exist?('log')
    
    File.open(log_file, 'a') do |f|
      timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')
      log_message = "[#{timestamp}] [#{action.to_s.upcase}] Module: #{module_name}"
      log_message += " - #{message}" if message
      f.puts log_message
    end
  end

  def force_mode?
    ARGV.include?('--force') || ARGV.include?('-f')
  end

  def get_module_version(module_template_path)
    version_path = File.join(module_template_path, 'VERSION')
    return '1.0.0' unless File.exist?(version_path)
    File.read(version_path).strip
  end

  def version_compare(version1, version2)
    # Simple semantic version comparison
    v1_parts = version1.split('.').map(&:to_i)
    v2_parts = version2.split('.').map(&:to_i)
    
    # Pad arrays to same length
    max_length = [v1_parts.length, v2_parts.length].max
    v1_parts += [0] * (max_length - v1_parts.length)
    v2_parts += [0] * (max_length - v2_parts.length)
    
    # Compare each part
    v1_parts.zip(v2_parts).each do |a, b|
      return 1 if a > b
      return -1 if a < b
    end
    0
  end

  def create_module_backup(module_name, version)
    timestamp = Time.now.strftime('%Y%m%d_%H%M%S')
    backup_dir = File.join('backups', 'synth_modules', "#{module_name}_v#{version}_#{timestamp}")
    
    FileUtils.mkdir_p(backup_dir)
    
    # Backup module files from app/domains
    domains_path = File.join('app', 'domains', module_name)
    if Dir.exist?(domains_path)
      FileUtils.cp_r(domains_path, File.join(backup_dir, 'app_domains'))
    end
    
    # Backup specs/tests
    ['spec', 'test'].each do |test_dir|
      test_path = File.join(test_dir, 'domains', module_name)
      if Dir.exist?(test_path)
        FileUtils.cp_r(test_path, File.join(backup_dir, "#{test_dir}_domains"))
      end
    end
    
    # Backup registry entry
    registry = load_registry
    module_registry = { 'module' => module_name, 'info' => registry.dig('installed', module_name) }
    File.write(File.join(backup_dir, 'registry.json'), JSON.pretty_generate(module_registry))
    
    backup_dir
  end

  def detect_conflicts(module_name, module_template_path)
    conflicts = []
    
    # Check if there are local modifications to module files
    domains_path = File.join('app', 'domains', module_name)
    return conflicts unless Dir.exist?(domains_path)
    
    # Look for files that exist in both template and current installation
    Dir.glob(File.join(module_template_path, "**/*")).each do |template_file|
      next if File.directory?(template_file)
      next if ['install.rb', 'remove.rb', 'VERSION'].include?(File.basename(template_file))
      
      relative_path = Pathname.new(template_file).relative_path_from(Pathname.new(module_template_path))
      current_file = File.join(domains_path, relative_path)
      
      if File.exist?(current_file)
        template_content = File.read(template_file)
        current_content = File.read(current_file)
        
        if template_content != current_content
          conflicts << {
            file: relative_path.to_s,
            template_path: template_file,
            current_path: current_file
          }
        end
      end
    end
    
    conflicts
  end

  def handle_conflicts(conflicts, module_name)
    puts "\n‚ö†Ô∏è  Found #{conflicts.length} file conflict(s) in #{module_name}:"
    conflicts.each { |c| puts "  üìÑ #{c[:file]}" }
    
    puts "\nConflict resolution options:"
    puts "  [o] Overwrite all with template versions"
    puts "  [k] Keep all current versions"
    puts "  [i] Review each conflict individually"
    puts "  [a] Abort upgrade"
    
    print "\nChoose option [o/k/i/a]: "
    choice = STDIN.gets.chomp.downcase
    
    case choice
    when 'o'
      # Overwrite all - do nothing, normal upgrade will handle this
      puts "üìù Will overwrite all conflicted files with template versions"
    when 'k'
      # Keep all - mark conflicts to skip
      conflicts.each { |c| c[:action] = :keep }
      puts "üìù Will keep all current file versions"
    when 'i'
      # Interactive review
      handle_conflicts_interactively(conflicts)
    when 'a'
      puts "‚ùå Upgrade aborted"
      exit 0
    else
      puts "‚ùå Invalid choice. Aborting upgrade."
      exit 1
    end
  end

  def handle_conflicts_interactively(conflicts)
    conflicts.each do |conflict|
      puts "\n" + "="*60
      puts "Conflict in: #{conflict[:file]}"
      puts "="*60
      
      puts "\n[1] Template version:"
      puts File.read(conflict[:template_path]).lines.first(5).join
      puts "... (truncated)" if File.read(conflict[:template_path]).lines.length > 5
      
      puts "\n[2] Current version:"
      puts File.read(conflict[:current_path]).lines.first(5).join
      puts "... (truncated)" if File.read(conflict[:current_path]).lines.length > 5
      
      print "\nChoose: [1] Use template, [2] Keep current, [s] Skip this file: "
      choice = STDIN.gets.chomp
      
      case choice
      when '1'
        conflict[:action] = :overwrite
      when '2'
        conflict[:action] = :keep
      when 's'
        conflict[:action] = :skip
      else
        puts "Invalid choice, keeping current version"
        conflict[:action] = :keep
      end
    end
  end

  def perform_module_upgrade(module_name, module_template_path, current_version, new_version)
    # Handle migrations first
    handle_module_migrations(module_name, module_template_path)
    
    # Handle configuration updates
    handle_module_config(module_name, module_template_path)
    
    # Update module files with conflict resolution
    update_module_files(module_name, module_template_path)
    
    # Handle seed data
    handle_module_seeds(module_name, module_template_path)
    
    # Update registry
    update_registry(module_name, {
      'version' => new_version,
      'installed_at' => Time.now.strftime('%Y-%m-%dT%H:%M:%S%z'),
      'template_path' => module_template_path,
      'previous_version' => current_version,
      'upgraded_at' => Time.now.strftime('%Y-%m-%dT%H:%M:%S%z')
    })
  end

  def handle_module_migrations(module_name, module_template_path)
    migration_path = File.join(module_template_path, 'db', 'migrate')
    return unless Dir.exist?(migration_path)
    
    puts "üóÑÔ∏è  Processing migrations for #{module_name}..." if @verbose
    
    # Copy migrations to main db/migrate directory
    Dir.glob(File.join(migration_path, "*.rb")).each do |migration_file|
      migration_name = File.basename(migration_file)
      target_path = File.join('db', 'migrate', migration_name)
      
      unless File.exist?(target_path)
        FileUtils.mkdir_p('db/migrate')
        FileUtils.cp(migration_file, target_path)
        puts "  ‚úÖ Copied migration #{migration_name}" if @verbose
      end
    end
  end

  def handle_module_config(module_name, module_template_path)
    config_path = File.join(module_template_path, 'config')
    return unless Dir.exist?(config_path)
    
    puts "‚öôÔ∏è  Processing configuration for #{module_name}..." if @verbose
    
    # Handle initializers
    initializers_path = File.join(config_path, 'initializers')
    if Dir.exist?(initializers_path)
      FileUtils.mkdir_p('config/initializers')
      Dir.glob(File.join(initializers_path, "*.rb")).each do |initializer|
        target_path = File.join('config/initializers', File.basename(initializer))
        FileUtils.cp(initializer, target_path)
        puts "  ‚úÖ Updated initializer #{File.basename(initializer)}" if @verbose
      end
    end
    
    # Handle routes
    routes_file = File.join(config_path, 'routes.rb')
    if File.exist?(routes_file)
      puts "  üìù Found routes file - manual integration may be required" if @verbose
    end
  end

  def update_module_files(module_name, module_template_path)
    # Use existing copy_module_files method but with conflict awareness
    copy_module_files(module_name, module_template_path)
  end

  def handle_module_seeds(module_name, module_template_path)
    seeds_path = File.join(module_template_path, 'db', 'seeds.rb')
    return unless File.exist?(seeds_path)
    
    puts "üå± Found seed data for #{module_name} - consider running: rails db:seed" if @verbose
    
    # Copy seeds to a module-specific location
    target_seeds_dir = File.join('db', 'seeds')
    FileUtils.mkdir_p(target_seeds_dir)
    target_seeds_file = File.join(target_seeds_dir, "#{module_name}_seeds.rb")
    FileUtils.cp(seeds_path, target_seeds_file)
    puts "  ‚úÖ Copied seeds to #{target_seeds_file}" if @verbose
  end
end

# Start the CLI
SynthCLI.start(ARGV) if __FILE__ == $0